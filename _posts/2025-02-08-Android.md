---
title: "Android 클린 아키텍처(작성중)"
date: 2025-02-08 17:00:00 +/-TTTT
categories: [Study, Android 클린 아키텍처]
tags: [android]
math: true
toc: true
pin: true
description: Android 클린 아키텍처에 대해 공부해봅시다.
---

## **1. 클린 아키텍처란?**
- 코드를 **읽기** 쉽고 **변경**하기 쉬운 구조
- 관심사 분리(각 모듈의 독립성)를 통해 실현
- 안드로이드에서만 사용가능한 구조는 아님

#### 엉클밥의 클린아키텍처

![clean_architecture](/assets/img/for_post/clean_architecture.jpg)

클린 아키텍처를 찾아보면 가장 많이 볼 수 있는 구조이다. 위 그림이 의미하는게 뭘까?
- 클린 아키텍처는 대표적으로 `Presenters`, `Use Cases`, `Entities` 세 레이어로 나뉜다 (의존성 규칙만 지킨다면 개수의 제한은 없다)
- 외부에서 내부로 의존성을 가지며, 그 반대는 존재하지 않는다
    - Use Cases는 Presenters의 존재를 모르고, Entities에 의존한다
    - Entities는 자신 외에 어떤 존재도 모른다
    - 이를 이용해 외부가 변경되더라도 내부가 변경되지 않는 구조를 만들 수 있다

&nbsp;

(예시) 쇼핑몰 결제방식 추가
- 쇼핑몰에 신규 결제 방식(ex. 애플페이)가 추가되었을 때 시스템의 핵심 로직이 함께 바뀌면 위험할 수 있다
- 클린 아키텍처가 적용된 시스템에서는 새로운 결제방식(Presenters)가 추가 되더라도 내부의 Use Cases와 Entities에 영향이 없다
- 단순히 새로운 결제 화면을 추가하고, 기존의 결제 로직을 가져와 사용하면 된다

&nbsp;

내부는 외부를 모르는데 어떻게 시스템이 동작할까?
- 결제를 하고 화면에 표시를 해주려면 내부가 외부에 대한 정보를 알아야 하는게 아닌가?
    - `추상화`를 이용한다
- 로직에 해당하는 영역을 인터페이스 형태로 설계하고, 외부에서 사용하는 시점에 구현하도록 한다
- 이를 통해 내부는 외부를 모르고, 외부또한 내부를 호출하지만 내부가 어떻게 동작하는지 관심을 가질 필요가 없게된다
    - 각 레이어가 `독립적`이게 된다

## **2. 안드로이드 클린 아키텍처의 구조**

![android_clean_architecture](/assets/img/for_post/android_clean_architecture.png)
위 사진은 엉클밥의 클린 아키텍처 개념을 안드로이드 프로그램에 적용하는 방법이다.
- 크게 `Presentation`, `Domain`, `Data` 레이어가 존재한다
- 가장 안쪽에 있는 레이어는 화살표가 나타내는 의존성 규칙에 따라 Domain 레이어가 가장 내부에 위치한다
    - Preesntation과 Data 레이어의 경우 Domain 레이어에 의존성을 갖는다

--------

#### Domain Layer

- 순수 비즈니스 로직과 앱의 핵심 규칙을 정의하는 layer
- 가장 안쪽이 있는 layer
    - 어떤 layer도 의존해서는 안됨
    - 안드로이드 플랫폼과도 독립적
- 어떤 변경이 있더라도 domain layer는 변경되지 않고, 비즈니스 로직이 바뀔때만 바뀔 수 있음
- 엉클밥의 클린 아키텍처에서 Use Cases와 Entity에 해당

Domain layer는 또 다시 `Entity`, `UseCase`, `Repository`로 나뉜다
- `Entity`: 비즈니스의 객체 (비즈니스를 구성하는 대상들)
```kotlin
// 쇼핑몰에선 상품, 고객, 주문건 등이 될 수 있다
data Class Product(val productId:Int, val name:String, val price:Double)
data Class Customer(val id:Int, val name:String)
data Class Order(val orderId:Int, val orderItems:ArrayList<Product>)
```
- `UseCase`: 앱에서 실행되는 비즈니스 로직
    - `Repository`를 사용하여 비즈니스 로직을 수행
```kotlin
interface GetProductUseCase {
    fun invoke(productId: Int): Product
}

class GetProductUseCaseImpl(private val productRepository: ProductRepository): GetProductUseCase {
    override fun invoke(productId: Int): Product {
        return productRepository.getProductById(productId)
    }
}
```
- `Repository`: Domain과 Data layer 연결를 연결하는 추상화
    - 인터페이스를 설계해놓으면 data layer에서 구현하여 사용하는 방식이기 때문에 domain은 data가 실제 어떻게 구현되었는지 알 지 못함
    - Domain는 data layer가 DB를 local, remote, 캐시 어디서 가져오는지 알 수 없음


도메인은 기획자와 역할이 비슷하다. 기획자가 수도코드를 작성한다면 어떻게 작성할것 같은지를 기반으로 설계.

--------

#### Data Layer

- 비즈니스에서 필요한 데이터를 제공하는 layer
- 비즈니스 로직과 무관하게 데이터 전달에만 집중
- Repository를 사용하여 domain layer와 연결

Data layer는 또 다시 `Repository Impl`, `DataSource`, `Model Mapper`로 나뉜다
- `Repository Impl`: Domain layer와 연결하기 위해서 domain layer의 추상화 클래스를 구현한 클래스다
- `Data Source`: 실제 데이터와 연결을 위한 추상화 클래스다
    - remote db, local db, 캐시 등에서 이를 구현하여 데이터를 전달한다 
    - LocalDataSource, RemoteDataSource 등으로 나뉠 수 있다

> (Bottom-Up 관점에선) data는 domian과 연결을 위해 domain 추상화를 구현하고, data source는 data와 연결을 위해 data 추상화를 구현한다

> (Top-Down 관점에선) 서비스의 비즈니스 로직을 담당하는 domain은 다른 모든 영역에 의존성을 갖지 않기 위해서 추상 클래스로 큰 흐름의 설계만 해놓고(마치 수도코드와 같이), 그 아래 영역 data, dataSouce에서 상위의 추상 클래스를 구현하여 세부적인 동작을 정의하는 방식이다

--------

#### Remote 

- 원격 서버와 통신하면서 데이터를 주고 받는 계층
- 데이터 요청, 응답 처리, 네트워크 오류 처리 등 포함
    - Retrofit(OkHttp)와 같은 라이브러리 활용
- Data layer와 연결을 위해 DataSource 추상 클래스를 구현한다

#### Local

- 로컬 데이터를 저장하고 읽어오는 layer
- 주로 DB(Room), SharedPreferences, 파일 시스템 등으로 관리
- 삭제될 수 있다는 가정으로 설계
    - 대부분 Nullable 리턴























&nbsp;&nbsp;&nbsp;&nbsp;

-------------------
-------------------

## References
1. [테드박의 안드로이드 앱 개발 : 확장성과 유지보수에 용이한 클린 아키텍처](https://fastcampus.co.kr/dev_online_clean)
2. 